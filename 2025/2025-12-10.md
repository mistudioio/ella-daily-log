## üß© What I worked on today

- Set up Fly.io deployment for the ShipSharp API.
- Created and configured a Fly PostgreSQL cluster (shipsharp-db).
- Generated full Fly secrets (JWT keys, Google OAuth, DB connection, etc.).
- Updated Dockerfile for production-ready .NET image and Fly deployment requirements.
- Updated Program.cs to correctly use environment variables in production.
- Connected ShipSharp API to Fly‚Äôs private Postgres using FLYCAST.
- Deployed multiple versions of the API and monitored logs via fly logs.
- Fixed app restart errors by correcting connection strings and Fly networking.
- Successfully saw the ShipSharp API reach the ‚Äúhealthy / running‚Äù state.
- Troubleshot local EF Core issues after deployment.
- Diagnosed and confirmed that local DB schema conflicts were expected (duplicate Identity tables).
- Planned next steps for improving developer setup and boilerplate structure.

## ü§î Notes / Problem Solving

- Fly Postgres requires PGBouncer-compatible parameters, and connection strings must use:
  `Host=shipsharp-db.flycast; Port=5432;`
  `SSL Mode=Disable`
- The API was repeatedly restarting because EF Core migrations were running before DB was reachable.
- The timeout errors came from:
  - DB not ready yet
  - Missing or incorrect Fly secrets
  - Conflicting EF migrations locally vs production
- Local dotnet run failed because the local DB already contained Identity tables ‚Üí EF migration tried to recreate them.
- Solution: drop local DB or reset migrations.

## üå± Learning

- Learned how Fly.io machines restart, deploy, and handle networking internally.
- Learned the difference between:
  - `fly deploy` (build + push + release)
  - `fly secrets set` (runtime configuration)
  - `fly ssh console` (advanced debugging)
- Understood how EF Core migrations interact with both Fly Postgres and local Postgres.
- Learned how to diagnose:
  - Npgsql connection timeouts
  - Migration lock behavior
  - Shadow state EF Core warnings
- Understood best practices for multi-environment boilerplate design, ensuring ShipSharp can run:
  - On Fly
  - On local machine
  - In Docker
  - Self-hosted by customers
- Learned how to structure environment variables so the same boilerplate can be deployed anywhere.
